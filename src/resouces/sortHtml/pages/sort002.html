

<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>十大经典排序算法</title>

<link type="text/css" rel="stylesheet" href="../css/index.css">
<link type="text/css" rel="stylesheet" href="../css/zhhNav.css">



</head>

<style type="text/css">	
</style>



<body>
<section class="demo">
    <ul class="nav black">
      <li><a href="sort001.html">首页</a></li>
      <li><a href="sort002.html">冒泡排序</a></li>
	   <li><a href="sort002.html">选择排序</a></li>
      <li><a href="sort003.html">插入排序、希尔排序</a></li>
      <li><a href="sort004.html">归并排序、快速排序</a></li>
      <li><a href="sort005.html">堆排序、计数排序</a></li>
    </ul>
    
	</section>
	<br/>
<div id="home">

<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		
<div id="post_detail">
<!--done-->
<div id="topics">
	<div class = "post">
	<div class = "h1Div">
			十大经典排序算法（第二话）
		</div>
	<br/>
<h3 id="1冒泡排序bubble-sort">1、冒泡排序（Bubble Sort）</h3>
<br/>
<p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。&nbsp;</p>
<br/>
<h4 id="2算法描述和实现">1.1 算法描述</h4>
<br/>
<ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>重复步骤1~3，直到排序完成。</li>
</ul>
<br/>
<p><strong>1.2 动图演示</strong></p>
<br/>
<p><img src="../images/849589-20171015223238449-2146169197.gif" alt="" width="681" height="212"></p>
<h4 id="2算法描述和实现">1.3 代码实现</h4>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">function bubbleSort(arr) {
    var len = arr.length;
    for (var i = 0; i &lt; len; i++) {
        for (var j = 0; j &lt; len - 1 - i; j++) {
            if (arr[j] &gt; arr[j+1]) {        //相邻元素两两对比
                var temp = arr[j+1];        //元素交换
                arr[j+1] = arr[j];
                arr[j] = temp;
            }
        }
    }
    return arr;
}</pre>
</div>
<br/>
<h4>1.4&nbsp;<strong>算法分析</strong></h4>
<br/>
<p>最佳情况：T(n) = O(n) &nbsp; 最差情况：T(n) = O(n2) &nbsp; 平均情况：T(n) = O(n2)</p>
<br/>
<h3 id="2选择排序selection-sort">2、选择排序（Selection Sort）</h3>
<br/>
<p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p>
<p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。&nbsp;</p>
<br/>
<h4 id="2算法描述和实现-1">2.1 算法描述</h4>
<br/>
<p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>
<ul>
<li>初始状态：无序区为R[1..n]，有序区为空；</li>
<li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>
<li>n-1趟结束，数组有序化了。</li>
</ul>
<br/>
<h4 id="2算法描述和实现"><strong>2.2 动图演示</strong></h4>
<br/>
<p><img src="../images/849589-20171015224719590-1433219824.gif" alt="" width="684" height="209">　　</p>
<br/>
<h4 id="2算法描述和实现">2.3 代码实现</h4>
<br/>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">function selectionSort(arr) {
    var len = arr.length;
    var minIndex, temp;
    for (var i = 0; i &lt; len - 1; i++) {
        minIndex = i;
        for (var j = i + 1; j &lt; len; j++) {
            if (arr[j] &lt; arr[minIndex]) {     //寻找最小的数
                minIndex = j;                 //将最小数的索引保存
            }
        }
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
    return arr;
}</pre>
</div>
<br/>
<h4>2.4&nbsp;<strong>算法分析</strong></h4>
<br/>
<p>最佳情况：T(n) = O(n2) &nbsp;最差情况：T(n) = O(n2) &nbsp;平均情况：T(n) = O(n2)</p>

<p><<上一篇：<a href='sort001.html'>排序算法简介</a></p>
<p>>>下一篇：<a href='sort003.html'>插入排序、希尔排序</a></p>

<p></p>
		</div>
	
	</div>
	
</div><!--end: topics 文章、评论容器-->
<div id='comment_form' class='commentform'>
<div id='comment_nav'><a href='#top'>返回顶部</a></div>

</div>
	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->
</body>
</html>
